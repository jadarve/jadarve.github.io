[{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://jadarve.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"Bazel is a good multi-platform, multi-language build system designed for correctness and scalability. It supports programming languages such as Go, C++, Java, and Python, through the use of rule systems for each of them. Rules are stored in repositories (git, http archives) and are downloaded on-demand when they are referenced.\nI use Bazel as the build system for my lluvia project. I use C++ as the core language of the project, Python for creating easy to use wrappers for prototyping, Lua for describing compute stages, and finally, GLSL for coding compute shaders that run on the GPU.\nFor GLSL and Vulkan, I used some custom rules coded within the project for defining shaders and shader libraries. As those rules grew, I saw the opportunity to maintain them as an independent project that can serve anyone trying to use GLSL and Vulkan in their project.\nrules_vulkan The rules_vulkan project provides rules for accessing the Vulkan SDK installed on the host system. By exposing the SDK to Bazel, one gets access to:\n The vulkan headers and libraries for creating C++ binaries. Shader tools such as glslc for compiling shaders into SPIR-V representation, among others.  Configuration Include the following configuration in your project\u0026rsquo;s WORKSPACE file.\nload(\u0026#34;@bazel_tools//tools/build_defs/repo:git.bzl\u0026#34;, \u0026#34;git_repository\u0026#34;) git_repository( name = \u0026#34;rules_vulkan\u0026#34;, remote = \u0026#34;https://github.com/jadarve/rules_vulkan.git\u0026#34;, tag = \u0026#34;v0.0.1\u0026#34; ) load(\u0026#34;@rules_vulkan//vulkan:repositories.bzl\u0026#34;, \u0026#34;vulkan_repositories\u0026#34;) vulkan_repositories() By calling vulkan_repositories(), the package will look for the Vulkan SDK installed in your Operating System and create the following extra repositories:\n   Repository Defined Targets     vulkan_windows vulkan_cc_library for compiling C/C++ targets that depend on Vulkan. glslc filegroup for the GLSL compiler, used internally to compile shaders.   vulkan_linux Nothing at the moment. The GLSL compiler is accessed directly from the system.    Rules glsl_header_library A GLSL header library defines a collection of .glsl files that can be included during compilation of a glsl_shader:\nload(\u0026#34;@rules_vulkan//glsl:defs.bzl\u0026#34;, \u0026#34;glsl_header_library\u0026#34;) glsl_header_library( name = \u0026#34;mylib_glsl_library\u0026#34;, hdrs = [ \u0026#34;mylib/mylib.glsl\u0026#34;, \u0026#34;mylib/color/color.glsl\u0026#34;, ], # path from the repository\u0026#39;s root that will be stripped strip_include_prefix = \u0026#34;shader_lib\u0026#34;, visibility = [\u0026#34;//visibility:public\u0026#34;] ) glsl_shader A glsl_shader compiles a shader file (.vert, .frag, .tesc, .tese, .geom, .comp) to SPIR-V representation:\nload(\u0026#34;@rules_vulkan//glsl:defs.bzl\u0026#34;, \u0026#34;glsl_shader\u0026#34;) glsl_shader( name = \u0026#34;assign_shader\u0026#34;, shader = \u0026#34;assign.comp\u0026#34;, deps = [ \u0026#34;//shader_lib:mylib_glsl_library\u0026#34; ], visibility = [\u0026#34;//visibility:public\u0026#34;] ) Referencing vulkan libraries in CC targets As mentioned above rules_vulkan also creates extra repositories to access the Vulkan SDK installed on the host operating system: vulkan_windows, and vulkan_linux. For Windows in particular, it currently defines the vulkan_cc_library to access the vulkan headers and libraries. Below is an example from the repo to compile a simple binary that lists the available extensions:\nload(\u0026#34;@rules_cc//cc:defs.bzl\u0026#34;, \u0026#34;cc_binary\u0026#34;) config_setting ( name = \u0026#34;linux\u0026#34;, constraint_values = [ \u0026#34;@platforms//os:linux\u0026#34; ], visibility = [\u0026#34;//visibility:public\u0026#34;] ) config_setting ( name = \u0026#34;windows\u0026#34;, constraint_values = [ \u0026#34;@platforms//os:windows\u0026#34; ], visibility = [\u0026#34;//visibility:public\u0026#34;] ) cc_binary( name = \u0026#34;list_extensions\u0026#34;, srcs = [ \u0026#34;list_extensions.cpp\u0026#34; ], linkopts = select({ \u0026#34;//:linux\u0026#34;: [ \u0026#34;-lvulkan\u0026#34;, ], \u0026#34;//:windows\u0026#34;: [], }), deps = select({ \u0026#34;//:windows\u0026#34;: [ \u0026#34;@vulkan_windows//:vulkan_cc_library\u0026#34;, ], \u0026#34;//conditions:default\u0026#34;: [], }), visibility = [\u0026#34;//visibility:public\u0026#34;] ) The code for list_extensions.cpp is:\n#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;iostream\u0026gt; #include \u0026lt;vulkan/vulkan.hpp\u0026gt; int main() { const vk::ApplicationInfo appInfo = vk::ApplicationInfo() .setPApplicationName(\u0026#34;list_extensions\u0026#34;) .setApplicationVersion(0) .setEngineVersion(0) .setPEngineName(\u0026#34;rules_vulkan\u0026#34;); const vk::InstanceCreateInfo instanceInfo = vk::InstanceCreateInfo() .setPApplicationInfo(\u0026amp;appInfo); vk::Instance instance; vk::Result result = vk::createInstance(\u0026amp;instanceInfo, nullptr, \u0026amp;instance); if (result != vk::Result::eSuccess) { std::cerr \u0026lt;\u0026lt; \u0026#34;error creating vulkan instance\u0026#34; \u0026lt;\u0026lt; std::endl; exit(-1); } auto extensions = vk::enumerateInstanceExtensionProperties(); for (const auto\u0026amp; ext: extensions) { std::cout \u0026lt;\u0026lt; ext.extensionName \u0026lt;\u0026lt; std::endl; } return EXIT_SUCCESS; } Future work In the example above, notice that for linux, the dependency on Vulkan is accessed directly from the OS. In particular for Ubuntu, the LunarG SDK can be installed using the regular apt install method and hence, the headers, libraries, and tools (glslc), are installed distributed across different folders in the system. This makes it hard for creating a vulkan_linux repository as I need to access several locations from the system. That still does not work.\nAlso, there is no support for MacOS at the moment.\n","date":"May 23, 2021","hero":"/images/default-hero.jpg","permalink":"https://jadarve.github.io/posts/rules_vulkan/","summary":"Bazel is a good multi-platform, multi-language build system designed for correctness and scalability. It supports programming languages such as Go, C++, Java, and Python, through the use of rule systems for each of them. Rules are stored in repositories (git, http archives) and are downloaded on-demand when they are referenced.\nI use Bazel as the build system for my lluvia project. I use C++ as the core language of the project, Python for creating easy to use wrappers for prototyping, Lua for describing compute stages, and finally, GLSL for coding compute shaders that run on the GPU.","tags":null,"title":"Introducing rules_vulkan for Bazel"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://jadarve.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://jadarve.github.io/posts/today-i-learned/","summary":"","tags":null,"title":"Today I learned"},{"categories":null,"contents":"Environment variables # get all variables Get-ChildItem Env: # get one (Path) Get-ChildItem Env:Path # set a variable $Env:VULKAN_SDK = \u0026#34;C:/VulkanSDK/1.2.176.1\u0026#34; # append to Path $Env:Path += \u0026#34;;C:/Python27\u0026#34;     ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://jadarve.github.io/notes/windows/","summary":"Environment variables # get all variables Get-ChildItem Env: # get one (Path) Get-ChildItem Env:Path # set a variable $Env:VULKAN_SDK = \u0026#34;C:/VulkanSDK/1.2.176.1\u0026#34; # append to Path $Env:Path += \u0026#34;;C:/Python27\u0026#34;     ","tags":null,"title":"Windows Notes"}]